// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2876.Steamworks2017.subsystems;

import org.usfirst.frc2876.Steamworks2017.Robot;
import org.usfirst.frc2876.Steamworks2017.RobotMap;
import org.usfirst.frc2876.Steamworks2017.commands.DriveControl;

import com.ctre.CANTalon;
import com.ctre.CANTalon.TalonControlMode;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.RobotDrive.MotorType;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveTrain extends Subsystem {
	public boolean invertMotor = true;
	public double getDistanceReturn = 1;
	private boolean toggleInverseDrive = false;
	private boolean toggleHelp;

	private final double MAX_RPM = 3127.0f;
	private final double kTurnToleranceDegrees = 2.0f;
	private final double kDistanceTolerance = 2.0f;
	private static final double WHEEL_DIAMETER = 6;
	private static final double PULSES_PER_REV = 4096;
	public double average;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon frontLeftTalon = RobotMap.driveTrainFrontLeftTalon;
	private final CANTalon frontRightTalon = RobotMap.driveTrainFrontRightTalon;
	private final CANTalon rearLeftTalon = RobotMap.driveTrainRearLeftTalon;
	private final CANTalon rearRightTalon = RobotMap.driveTrainRearRightTalon;
	private final Relay lightSpike = RobotMap.driveTrainLightSpike;
	private final Encoder leftEncoder = RobotMap.driveTrainLeftEncoder;
	private final Encoder rightEncoder = RobotMap.driveTrainRightEncoder;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public RobotDrive myRobot;

	public CameraServer server;
	public PIDController straightController;
	public PIDController distanceController;
	public PIDController turnController;
	public AHRS navx;
	private CANTalon rightMaster, leftMaster;

	public DriveTrain() {
		// frontRightTalon.setInverted(invertMotor);
		// rearRightTalon.setInverted(invertMotor);
		navx = new AHRS(SPI.Port.kMXP);

		myRobot = new RobotDrive(frontLeftTalon, rearLeftTalon, frontRightTalon, rearRightTalon);
		myRobot.setSafetyEnabled(false);
		myRobot.setInvertedMotor(MotorType.kRearLeft, false);
		myRobot.setInvertedMotor(MotorType.kFrontRight, true);
		myRobot.setInvertedMotor(MotorType.kRearRight, true);
		myRobot.setInvertedMotor(MotorType.kFrontLeft, false);

		initializeCamera();

		straightController = new PIDController(10, 0, 0, navx, new PIDOutput() {
			public void pidWrite(double output) {

				SmartDashboard.putNumber("StraightPidOutput", output);
			}
		});
		straightController.setOutputRange(-MAX_RPM, MAX_RPM);

		distanceController = new PIDController(10, 0, 0, 10, new AvgEncoder(), new PIDOutput() {
			public void pidWrite(double output) {

				SmartDashboard.putNumber("distancePidOutput", output);
			}
		});
		distanceController.setOutputRange(-MAX_RPM, MAX_RPM);
		distanceController.setAbsoluteTolerance(kDistanceTolerance);

		turnController = new PIDController(15, 0, 0, navx, new PIDOutput() {
			public void pidWrite(double output) {
				double minMove = 400.0f;
				SmartDashboard.putNumber("TurnPidOutput", output);
				if (Math.abs(output) < minMove) {
					if (output < 0) {
						output = -minMove;
					} else if (output > 0) {
						output = minMove;
					}
				}

				leftMaster.set(-output);
				rightMaster.set(output);

			}
		});
		turnController.setOutputRange(-MAX_RPM, MAX_RPM);
		// turnController.setOutputRange(-10,10);
		turnController.setInputRange(-180.0f, 180.0f);
		turnController.setAbsoluteTolerance(kTurnToleranceDegrees);
		turnController.setContinuous(true);

		// leftEncoder.setDistancePerPulse(Math.PI * WHEEL_DIAMETER / 1024 *
		// GEAR_RATIO);
		// rightEncoder.setDistancePerPulse(Math.PI * WHEEL_DIAMETER / 1024 *
		// GEAR_RATIO);

		// rearLeftTalon.configEncoderCodesPerRev((int)PULSES_PER_REV);
		// rearRightTalon.configEncoderCodesPerRev((int)PULSES_PER_REV);

		// for slave mode
		frontLeftTalon.changeControlMode(CANTalon.TalonControlMode.Follower);
		frontLeftTalon.set(rearLeftTalon.getDeviceID());
		frontRightTalon.changeControlMode(CANTalon.TalonControlMode.Follower);
		frontRightTalon.set(rearRightTalon.getDeviceID());
		leftMaster = rearLeftTalon;
		rightMaster = rearRightTalon;

		rearRightTalon.reverseOutput(true);

		rearRightTalon.changeControlMode(TalonControlMode.Speed);
		rearLeftTalon.changeControlMode(TalonControlMode.Speed);

	}

	public void initializeCamera() {
		server = CameraServer.getInstance();
		// server.setQuality(50);
		server.startAutomaticCapture("cam0", 0);

	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new DriveControl());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void updateSmartDashboard() {
		// boolean sensorPluggedIn =
		// (frontRightTalon.isSensorPresent(FeedbackDevice.QuadEncoder) ==
		// FeedbackDeviceStatus.FeedbackStatusPresent);
		// SmartDashboard.putBoolean("fr encoder isSensorPresent ",
		// sensorPluggedIn);
		// SmartDashboard.putData("Left Encoder", getLeftEncoder());
		// SmartDashboard.putData("Right Encoder", getRightEncoder());
		// SmartDashboard.putNumber("Right Encoder d",
		// leftEncoder.getDistance());
		// SmartDashboard.putNumber("Left Encoder d",
		// rightEncoder.getDistance());

		SmartDashboard.putBoolean("is navX connected", navx.isConnected());
		SmartDashboard.putBoolean("is navX calibrating", navx.isCalibrating());
		SmartDashboard.putData("NavX", navx);
		SmartDashboard.putBoolean("is navX moving", navx.isMoving());
		SmartDashboard.putBoolean("is navX rotating", navx.isRotating());
		SmartDashboard.putNumber("navX angle", navx.getAngle());
		SmartDashboard.putNumber("navX pitch", navx.getPitch());
		SmartDashboard.putNumber("navX yaw", navx.getYaw());
		SmartDashboard.putNumber("navX roll", navx.getRoll());
		SmartDashboard.putNumber("navX WorldX", navx.getWorldLinearAccelX());
		SmartDashboard.putNumber("navX WorldY", navx.getWorldLinearAccelY());
		// SmartDashboard.putNumber("Accel RoboRio", accel.getAcceleration());
		// SmartDashboard.putBoolean("is crossing", isCrossing);
		SmartDashboard.putNumber("frontLeftValue", frontLeftTalon.get());
		SmartDashboard.putNumber("frontRightValue", frontRightTalon.get());
		SmartDashboard.putNumber("rearLeftValue", rearLeftTalon.get());
		SmartDashboard.putNumber("rearRightValue", rearRightTalon.get());

		SmartDashboard.putNumber("LeftMasterSetpoint", leftMaster.getSetpoint());
		SmartDashboard.putNumber("RightMasterSetpoint", rightMaster.getSetpoint());

		SmartDashboard.putData("Straight PID", straightController);
		SmartDashboard.putNumber("Straight PID get", straightController.get());

		SmartDashboard.putData("Distance PID", distanceController);
		SmartDashboard.putNumber("Distance PID get", distanceController.get());

		SmartDashboard.putData("Turn PID", turnController);
		SmartDashboard.putNumber("Turn PID get", turnController.get());

		SmartDashboard.putNumber("Distance", getDistance());
		SmartDashboard.putNumber("Left Encoder Value", rearLeftTalon.getEncPosition());
		SmartDashboard.putNumber("Right Encoder Value", rearRightTalon.getEncPosition());
		SmartDashboard.putNumber("average", average);

	}

	public void resetEncoders() {
		rearLeftTalon.setEncPosition(0);
		rearRightTalon.setEncPosition(0);
	}

	public double getDistance() {

		average = (rearLeftTalon.getEncPosition() + rearRightTalon.getEncPosition()) / 2;
		// return average / (Math.PI * WHEEL_DIAMETER * GEAR_RATIO);
		return average / PULSES_PER_REV * Math.PI * WHEEL_DIAMETER;
	}

	public void setSpeed(double speed) {
		myRobot.arcadeDrive(speed, -straightController.get(), true);
		SmartDashboard.putNumber("Speed", speed);
	}

	public void velocityTankStraightJoysticks(double speed) {
		double straight = straightController.get();
		rearRightTalon.set((speed * 3127) + straight);
		rearLeftTalon.set((speed * 3127) - straight);
	}

	public void velocityDistanceStraight() {
		double straight = straightController.get();
		double distance = -distanceController.get();
		double r = distance + straight;
		double l = distance - straight;
		// TODO if r/l are less then some min, 300, 400? set to that min else
		// the robot won't move. Need a min value to make robot overcome
		// friction/inertia. Or better PID tuning?
		rightMaster.set(r);
		leftMaster.set(l);
	}

	public void setVelocityMode() {
		rearRightTalon.changeControlMode(TalonControlMode.Speed);
		rearLeftTalon.changeControlMode(TalonControlMode.Speed);
	}

	public void setVbusMode() {
		// TODO Fill this in
	}

	public void setVelocityJoysticks(double speed, double rotate) {
		if (speed > 0.0) {
			if (rotate > 0.0) {
				rearLeftTalon.set((speed - rotate) * 3127);
				rearRightTalon.set(Math.max(speed, rotate) * 3127);
			} else {
				rearLeftTalon.set(Math.max(speed, -rotate) * 3127);
				rearRightTalon.set((speed + rotate) * 3127);
			}
		} else {
			if (rotate > 0.0) {
				rearLeftTalon.set(-Math.max(-speed, rotate) * 3127);
				rearRightTalon.set((speed + rotate) * 3127);
			} else {
				rearLeftTalon.set((speed - rotate) * 3127);
				rearRightTalon.set(-Math.max(-speed, -rotate) * 3127);
			}
		}
		// rearRightTalon.set(speed * 3127);
		// rearLeftTalon.set (speed * 3127);

		// we multiplied speed (-1 - 1) by 3127, which is the native units per
		// 100 ms

	}

	public boolean toggleInverseDrive() {

		if (Robot.oi.selectButton.get() && toggleHelp) {
			toggleInverseDrive = !toggleInverseDrive;
		}
		toggleHelp = !Robot.oi.selectButton.get();
		return toggleInverseDrive;

	}

	// Using talon position mode(PID) to drive a set distance. Will this work
	// for going in a straight line? Or are we going to have use talon in
	// velocity mode and cascade PIDs like for turn and straight?

	// public void startDistance(double d) {
	// // TODO
	// // d is in inches.. convert it to native units
	// leftMaster.changeControlMode(TalonControlMode.Position);
	// rightMaster.changeControlMode(TalonControlMode.Position);
	// leftMaster.set(d);
	// rightMaster.set(d);
	// }
	//
	// public boolean isDistanceDone() {
	// double lerr = leftMaster.getClosedLoopError();
	// double rerr = rightMaster.getClosedLoopError();
	// // TODO: just a guess at error.. need to test.
	// return ((lerr + rerr) / 2) < 100;
	// }
	//
	// public void stopDistance() {
	// leftMaster.changeControlMode(TalonControlMode.Speed);
	// rightMaster.changeControlMode(TalonControlMode.Speed);
	// leftMaster.set(0);
	// rightMaster.set(0);
	// }

	public void startDistance(double distance) {
		stopTurn();
		distanceController.reset();
		resetEncoders();
		distanceController.setSetpoint(distance);
		distanceController.enable();
	}

	public boolean isDistanceRunning() {
		return distanceController.isEnabled();
	}

	public boolean isDistanceDone() {
		return distanceController.onTarget();
	}

	public void stopDistance() {
		distanceController.reset();
		leftMaster.set(0);
		rightMaster.set(0);

	}

	public void startTurn(double angle) {
		SmartDashboard.putNumber("TurnPidOutput", 0);
		navx.reset();
		stopStraight();
		turnController.reset();
		turnController.setSetpoint(angle);
		turnController.enable();
	}

	public boolean isTurnRunning() {
		return turnController.isEnabled();
	}

	public boolean isTurnDone() {
		return turnController.onTarget();
	}

	public void stopTurn() {
		SmartDashboard.putNumber("TurnPidOutput", 0);
		turnController.reset();
		leftMaster.set(0);
		rightMaster.set(0);
		navx.reset();
	}

	public void startStraight() {
		stopTurn();
		straightController.reset();
		straightController.setSetpoint(navx.getAngle());
		straightController.enable();
	}

	public void stopStraight() {
		straightController.reset();
		leftMaster.set(0);
		rightMaster.set(0);

	}

	public PIDController getDistancePID() {
		return distanceController;
	}

	public PIDController getTurnPID() {
		return turnController;
	}

	public PIDController getStraightPID() {
		return straightController;
	}

	public double nativeToInches(double nativeUnits) {
		double circumference = Math.PI * WHEEL_DIAMETER;
		return (nativeUnits / PULSES_PER_REV) * circumference;
	}

	private class AvgEncoder implements PIDSource {

		public double pidGet() {
			double l = nativeToInches(leftMaster.getEncPosition());
			double r = nativeToInches(rightMaster.getEncPosition());
			double av = (r - l) / 2;
			SmartDashboard.putNumber("Left distance", l);
			SmartDashboard.putNumber("Right distance", r);
			SmartDashboard.putNumber("Average distance", av);
			return av;
		}

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
			// TODO Auto-generated method stub

		}

		@Override
		public PIDSourceType getPIDSourceType() {
			// TODO Auto-generated method stub
			return PIDSourceType.kDisplacement;
		}
	}
}
